/// Generates the `GoogleFonts` class.

let crypto = require('crypto');
let fs = require('fs');
let path = require('path');

let cliProgress = require('cli-progress');
let fetch = require('cross-fetch');
let letfPad = require('left-pad');
let protocolBuffers = require('protocol-buffers');

async function main({ verify } = { verify: true }) {
  console.log('Getting latest font directory...');
  let protoUrl = await _getProtoUrl();
  console.log(`Got font directory. Using ${protoUrl}`);

  let fontDirectory = await _readFontsProtoData(protoUrl);
  if (verify) {
    console.log('Validating font URLs and file contents...');
    await _verifyUrls(fontDirectory);
    console.log('done.');
  } else {
    console.log('Skipping validation of font URLs and file contents.');
  }

  const generatedFilePath = '../expo-google-fonts/index.js';
  console.log(`Generating ${generatedFilePath}...`);
  await _writeJSFile(generatedFilePath, await _generateJSCode(fontDirectory));
  console.log('done');
}

// /// Gets the latest font directory.
// ///
// /// Versioned directories are hosted on the Google Fonts server. We try to fetch
// /// each directory one by one until we hit the last one. We know we reached the
// /// end if requesting the next version results in a 404 response.
// /// Other types of failure should not occur. For example, if the internet
// /// connection gets lost while downloading the directories, we just crash. But
// /// that's okay for now, because the generator is only executed in trusted
// /// environments by individual developers.
async function _getProtoUrl({ initialVersion } = { initialVersion: 1 }) {
  let directoryVersion = initialVersion;

  let url = () => {
    let paddedVersion = letfPad(directoryVersion + '', 3, '0');
    return `http://fonts.gstatic.com/s/f/directory${paddedVersion}.pb`;
  };

  let didReachLatestUrl = false;
  while (!didReachLatestUrl) {
    let response = await fetch(url(directoryVersion));
    if (response.status === 200) {
      directoryVersion++;
    } else if (response.status === 404) {
      didReachLatestUrl = true;
      directoryVersion--;
    } else {
      throw new Error(`Request failed: ${response}`);
    }
  }

  return url(directoryVersion);
}

function _spacesToUnderscores(s) {
  return s.replace(/\s+/g, '_');
}

async function _writeJSFile(fileName, code) {
  return await fs.promises.writeFile(fileName, code, 'utf8');
}

async function _generateJSCode(fontDirectory) {
  // Use named exports for all of these so that tree shaking
  // will keep this from getting too big
  let code = `
/**
 * This code is generated by \`generate/genertor.js\`
 * Do not hand modify this code unless you know what you are doing
 * Instead, modify the generation code there and re-run it.
 */

 import { useFont } from '@use-expo/font';

`;
  for (let family of fontDirectory.family) {
    let familyName = family.name.replace(/\s+/g, '_');
    for (let font of family.fonts) {
      let ttfUrl = _urlForFont(font);
      let weights = {
        '100': 'Thin',
        '200': 'ExtraLight',
        '300': 'Light',
        '400': 'Regular',
        '500': 'Medium',
        '600': 'SemiBold',
        '700': 'Bold',
        '800': 'ExtraBold',
        '900': 'Black',
      };
      let weightNumber = font.weight.start;
      let weightName = weights[weightNumber];
      let weightPart = '' + weightName + weightNumber;
      let fontIdentifier = _spacesToUnderscores(familyName);
      // let fontIdentifierNumber = fontIdentifier;
      if (weightPart) {
        fontIdentifier += '_' + weightPart;
      }
      let isItalic = font.italic.start === 1;
      if (isItalic) {
        fontIdentifier += '_Italic';
      }
      // if (weightName !== weightNumber + '') {
      //   fontIdentifierNumber += '_' + weightNumber;
      //   if (isItalic) {
      //     fontIdentifierNumber += '_Italic';
      //   }
      // } else {
      //   fontIdentifierNumber = null;
      // }
      let hookName = 'useGoogleFont_' + fontIdentifier;
      let arg = { [fontIdentifier]: ttfUrl };

      code += `export let ${hookName} = (fontFamily) => useFonts({[fontFamily ?? ${JSON.stringify(
        fontIdentifier
      )}]: ${JSON.stringify(ttfUrl)}});\n`;
      //       if (fontIdentifierNumber) {
      //         code += `
      // export let useGoogleFont_${fontIdentifierNumber} = ${hookName};
      //         `;
      //       }
    }
  }
  return code;
}

function _urlForFont(font) {
  return `https://fonts.gstatic.com/s/a/${_hashToString(font.file.hash)}.ttf`;
}

async function _verifyUrls(fontDirectory) {
  let totalFonts = 0;
  for (let family of fontDirectory.family) {
    totalFonts += family.fonts.length;
  }

  // TODO: We could probably parallelize these network requests and do
  // something like 4 - 10 at a time and this would be faster
  let bar = new cliProgress.SingleBar(
    {
      format: ' {bar} {percentage}% | ETA: {eta}s | {value}/{total} | {fontFamily}',
      clearOnComplete: true,
    },
    cliProgress.Presets.shades_classic
  );
  bar.start(totalFonts, 0);
  try {
    let i = 0;
    for (let family of fontDirectory.family) {
      for (let font of family.fonts) {
        let urlString = _urlForFont(font);
        await _tryUrl(urlString, font);
        i++;
        bar.update(i, { fontFamily: family.name });
      }
    }
    for (let i = 0; i < totalFonts; i++) {
      let delayAsync = require('delay-async');
      await delayAsync(1);
      bar.update(i);
    }
  } catch (e) {
    throw e;
  } finally {
    bar.stop();
  }

  return { totalFonts };
}

async function _tryUrl(url, font) {
  try {
    let response = await fetch(url);
    let fileContents = await response.buffer();
    let actualFileLength = fileContents.byteLength;
    let hash = crypto.createHash('sha256');
    hash.update(fileContents);
    let actualFileHash = hash.digest('hex');
    if (font.file.file_size !== actualFileLength) {
      throw new Error(
        `Font from ${url} did not match length\nfont.file.file_size=${font.file.file_size} actualFileLength=${actualFileLength}`
      );
    }
    if (_hashToString(font.file.hash) !== actualFileHash) {
      throw new Error(
        `Font from ${url} did not match checksum\nfont.file.hash=${font.file.hash}\nactualFileHash=${actualFileHash}`
      );
    }
  } catch (e) {
    console.error(`Failed to load font from ${url}\n${e}`);
    throw e;
  }
}

function _hashToString(bytes) {
  return bytes.toString('hex');
}

async function _readFontsProtoData(protoUrl) {
  let protoDef = await fs.promises.readFile(path.join(__dirname, 'fonts.proto'));
  let messages = protocolBuffers(protoDef);
  let response = await fetch(protoUrl);
  let fontsProtoFile = await response.buffer();
  let directory = messages.Directory.decode(fontsProtoFile);
  return directory;
}

function _familyToMethodName(family) {
  let words = family.split(/\s+/);
  let x = [];
  for (let i = 0; i < words.length; i++) {
    let word = words[i];
    let isFirst = i === 0;
    let isUpperCase = word === word.toUpperCase();
    x.push(
      (isFirst ? word[0].toLowerCase() : word[0].toUpperCase()) +
        (isUpperCase ? word.substr(1).toLowerCase() : word.substr(1))
    );
  }
  return x.join('');
}

async function __getPb() {
  let protoUrl = await _getProtoUrl();
  let r = await fetch(protoUrl);
  let pb = await r.text();
  return pb;
}

async function test() {
  let d = await __getDirectory();
  let c = _generateJSCode(d);
  console.log(_generateJSCode(d));
  return c;
  // return _verifyUrls(await __getDirectory());
  return null;
}

async function __getDirectory() {
  let pu = await _getProtoUrl();
  return _readFontsProtoData(pu);
}

async function __getCode() {
  let d = await __getDirectory();
  console.log(_generateJSCode(d));
}

module.exports = {
  _verifyUrls,
  test,
  __getDirectory,
  _getProtoUrl,
  _readFontsProtoData,
  main,
  __getPb,
  _hashToString,
  _tryUrl,
  _familyToMethodName,
};
